// each entry in process table contains 16 words so we multiply by 16 
// the 13th word had the UTPR
// this code does UTPR = SP
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
// UArea Page number is in PROCESS_TABLE +  PID * 16 since there are 16 words in each entry
// Setting SP to UArea Page number * 512 - 1 (kernel stack)
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;
backup;
// -- Pager Module Code --

// If swapping is initiated, (Check SYSTEM_STATUS_TABLE PAGING_STATUS == 1)
if([SYSTEM_STATUS_TABLE+5] == 1) then

    // if the current process is the Swapper Daemon and Paging Status is SWAP_OUT,
    if([SYSTEM_STATUS_TABLE+1] == 15 && [SYSTEM_STATUS_TABLE+5] == 0) then

        // Call the swap_out() function in the Pager Module.
        // Arguments are PID
        R1 = SWAP_OUT;
        R2 = [SYSTEM_STATUS_TABLE+1];
        call PAGER_MODULE;
    else

        if([SYSTEM_STATUS_TABLE+1] == 15 && [SYSTEM_STATUS_TABLE+5] == 1) then

            // Call the swap_in() function in the Pager Module.
            // Arguments are PID
            R1 = SWAP_IN;
            R2 = [SYSTEM_STATUS_TABLE+1];
            call PAGER_MODULE;
        endif;

        // else if the current process is Idle,                          
        // Swapping is ongoing, but the daemon is blocked for some disk operation and idle is being run now 
        // Skip to the end to perform context switch. 
    

    endif;

else
// Swapping is not on now.  Check whether it must be initiated


   // if (MEM_FREE_COUNT < MEM_LOW)      [SYSTEM_STATUS_TABLE+2]
    if([SYSTEM_STATUS_TABLE+2]< MEM_LOW) then
        // Swap Out to be invoked during next Timer Interrupt
        // Set the Paging Status in System Status Table to SWAP_OUT.
        [SYSTEM_STATUS_TABLE+5] = 0;


    else
        // else if (there are swapped out processes)            (Check SWAPPED_COUNT in System Status Table )
        if([SYSTEM_STATUS_TABLE+4]>0)then

            
            // if (Tick of any Swapped Out process > MAX_TICK or MEM_FREE_COUNT > MEM_HIGH)
            alias iter R1;
            alias processTableEntryAddress R2;
            iter = 0;

            // if MEM_FREE_COUNT is greater than MEM_HIGH
            if([SYSTEM_STATUS_TABLE+2] > MEM_HIGH ) then
                            
                // Set the Paging Status in System Status Table to SWAP_IN.
                [SYSTEM_STATUS_TABLE+5] = 1;                            
                iter = MAX_PROC_NUM;
            endif;

            while(iter < MAX_PROC_NUM-1) do
                processTableEntryAddress  = PROCESS_TABLE + 16 * iter; 
                
                // if any process has TICK greater than MAX_TICK
                if([processTableEntryAddress] > MAX_TICK ) then

                    // Set the Paging Status in System Status Table to SWAP_IN.
                    [SYSTEM_STATUS_TABLE+5] = 1;                            
                    break;

                endif;


                iter = iter +1;
            endwhile;

        endif;

    endif;

endif;






// -- Pager Module Code --




// The Process table entry of the current process can be computed as PROCESS_TABLE + currentPID*16. Save the KPTR, PTBR and PTLR values to the Process Table entry of the current process. Set the state of the process as READY.
alias process_table_entry R1;
process_table_entry = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16;

// changing status of the current program to ready
[process_table_entry + 4] = READY;

// 2 Obtain the PID of currently executing process from System Status Table.
alias currentPID R0;
currentPID = [SYSTEM_STATUS_TABLE+1];

// increasing tick of every program
alias iter R1;
iter=0;
while(iter<MAX_PROC_NUM-1) do
    [PROCESS_TABLE + iter*16 ] = [PROCESS_TABLE + iter*16] + 1;
    iter = iter +1;
endwhile;


// Scheduling algorithm round robin
call SCHEDULER;


restore;

// this code does SP = UTPR;
SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13];
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 9]=0; // MODE
ireturn;