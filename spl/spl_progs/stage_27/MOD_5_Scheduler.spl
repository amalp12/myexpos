// Pushing BP of current process
multipush(BP);
// 2 Obtain the PID of currently executing process from System Status Table.
alias currentPID R0;
currentPID = [SYSTEM_STATUS_TABLE+1];
alias process_table_entry R1;
process_table_entry = PROCESS_TABLE + currentPID * 16;

alias iter R4;
alias new_process_table R3;
alias newPID R2;
alias pagingProcessPID R5;
pagingProcessPID = 15;


// if (PAGING_STATUS in the System Status Table is not 0) (Paging is ongoing )
if( [SYSTEM_STATUS_TABLE + 5] != 0 ) then

    // If the paging process is blocked  ( the paging process is executing a disk operation )
    if([PROCESS_TABLE + 16*pagingProcessPID +4] == WAIT_DISK) then
        // Choose Idle Process for scheduling.
        newPID = 0;
    else
        // Choose the Swapper Daemon to be scheduled.
        newPID = 15;

    endif;

else
    //  Find the next non swapped process to schedule using the Round Robin scheduling technique, 

    // Round Robin algorithm for scheduling

    // Iterate through the Process Table entries, starting from the succeeding entry of the current process to find a process in READY or CREATED state.
    // If no such process can be found, select the idle process as the new process to be scheduled. Save PID of new process to be scheduled as newPID.

    newPID =0;
    iter =  [SYSTEM_STATUS_TABLE+1]+1; // current id +1

    while(iter<MAX_PROC_NUM-1) do
        process_table_entry = PROCESS_TABLE + iter * 16;
        if(([process_table_entry + 4] == READY) || ([process_table_entry + 4] == CREATED) ) then
            newPID = iter;
            break;
        endif;
        iter=iter+1;
    endwhile;


endif;



// Note that instead of saving the actual value of KPTR, we are saving KPTR%512. This is because the OS design stipulates that KPTR must contain the offset of the kernel stack pointer within the User Area Page. This is done so as to allow the OS to relocate the User Area Page if necessary.
process_table_entry = PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1] * 16; 
[process_table_entry + 12] = SP % 512;
[process_table_entry + 14] = PTBR;
[process_table_entry + 15] = PTLR;



//  Restore the SP, PTBR and PTLR values from the Process Table entry for the new process.
new_process_table = PROCESS_TABLE + newPID * 16;
//Set back Kernel SP, PTBR , PTLR
SP =  [new_process_table + 11] * 512 + [new_process_table + 12] ;
PTBR = [new_process_table + 14];
PTLR = [new_process_table + 15];

// Set the PID field of the System Status Table as newPID.
[SYSTEM_STATUS_TABLE + 1] = newPID;

if([new_process_table + 4] == CREATED) then
    SP = [new_process_table +13];

    // Store the value in the first word of the kernel stack to the BP register.
    [new_process_table + 4] = RUNNING;
    [new_process_table + 9] = 0; // MODE FLAG
    BP = [[new_process_table + 11] * 512];
    ireturn;
endif;
[new_process_table + 4] = RUNNING;
multipop(BP);
return;
