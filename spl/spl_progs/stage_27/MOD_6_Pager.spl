// Arguments are PID
alias functionNumber R1; // Function number
alias processId R2; // Process ID




if(functionNumber == SWAP_OUT) then
    // Choose a process to swap out. (other than the IDLE, Shell or INIT)

    alias swapOutProcessId R3; // Process ID to swap out
    alias processTableEntryAddress R4;
    alias iter R5; // Loop iterator
    
    // Temporary registers in use
    alias nonSwappedWaitProcessPid R6;
    alias nonSwappedWaitSemaphorePid R7;
    alias highestTickCount R8;
    alias highestTickProcessPid R9; 
    iter = 3;
    nonSwappedWaitProcessPid = -1;
    nonSwappedWaitSemaphorePid = -1;
    highestTickProcessPid = -1;
    highestTickCount = 0;

    while(iter < MAX_PROC_NUM) do
        processTableEntryAddress = PROCESS_TABLE + iter * 16;
        
        //    Loop through the Process Table and find a non-swapped process that is in the WAIT_PROCESS state.
        if([processTableEntryAddress + 4] == WAIT_PROCESS) then
            nonSwappedWaitProcessPid = iter;
            break;
        endif;

        //    If there are no non-swapped processes in the WAIT_PROCESS state, find a non-swapped process in the WAIT_SEMAPHORE state.
        if([processTableEntryAddress + 4] == WAIT_SEMAPHORE) then
            nonSwappedWaitSemaphorePid = iter;
        endif;

        //    If there are no non-swapped processes in the WAIT_PROCESS and WAIT_SEMAPHORE state, 
        if([processTableEntryAddress + 4] == WAIT_SEMAPHORE) then
            nonSwappedWaitProcessPid = iter;
        endif;
        
        //  find process with the highest TICK which is not running, terminated, allocated or swapped.
        if([processTableEntryAddress]>highestTickCount) then
            highestTickCount = [processTableEntryAddress];
            highestTickProcessPid = iter;
        endif;

        iter = iter +1;

    endwhile;

    if(nonSwappedWaitProcessPid != -1) then
        swapOutProcessId = nonSwappedWaitProcessPid;
    else
        if(nonSwappedWaitSemaphorePid != -1) then
            swapOutProcessId = nonSwappedWaitSemaphorePid;
        else
            if(highestTickProcessPid != -1) then
                swapOutProcessId = highestTickProcessPid;
            else
                //If no such process exists, 
                // set the PAGING_STATUS back to 0 and return.
                [SYSTEM_STATUS_TABLE+5] = 0;
                return;

            endif;
        endif;
    endif;


    // Set the TICK field of the process table entry of the selected process to 0.( When the process goes to swap, TICK starts again )
    [processTableEntryAddress]=0;


    iter =8;
    alias ptbr R6;
    ptbr = [processTableEntryAddress + 14];

    // Temporary registers in use
    alias codePageAddress R7;

    while(iter < 16) do
        codePageAddress = ptbr + iter;
        
        // Call the release_page() function in the Memory Manager module to deallocate the valid code pages of the process.
        if([codePageAddress] != -1) then // if code page number is not equal to -1 then

            multipush(R1,R2,R3,R4,R5,R6);
            R1 = RELEASE_PAGE;
            R2 = [codePageAddress];
            call MEMORY_MANAGER;
            multipop(R1,R2,R3,R4,R5,R6);
            
            // Invalidate the Page table entry corresponding to the code pages.
            [codePageAddress] = -1;
            [codePageAddress + 1] = "0000";

        endif;
        iter = iter + 2;
    endwhile;

    alias diskMapHeapEntryAddress R7;
    diskMapHeapEntryAddress =  DISK_MAP_TABLE + swapOutProcessId * 10   ;

    iter = 4;

    // Temporary registers in use
    alias heapPageAddress R8;

    while(iter < 8) do
        heapPageAddress = ptbr + iter;
        
        // For each heap page that is not shared and is valid (  Shared heap pages are not swapped out. )
        if([heapPageAddress] != -1 && [MEMORY_FREE_LIST+[heapPageAddress]] == 1) then // if heap page number is not equal to -1 then

            // Get a free swap block by calling the get_swap_block() function in the Memory Manager module.
            multipush(R1,R2,R3,R4,R5,R6,R7,R8);
            multipush(R5,R7,R8); // iter,diskMapHeapEntryAddress,heapPageAddress
            // No arguments
            // returns Block Number
            R1 = GET_SWAP_BLOCK;
            call MEMORY_MANAGER;
            
            
            alias swapBlockNumber R0;
            multipop(R5,R7,R8); // iter,diskMapHeapEntryAddress,heapPageAddress

            // Store the disk block number in the Disk Map Table entry of the process curresponding to the heap page.
            [diskMapHeapEntryAddress + iter/2] = swapBlockNumber;

            multipush(R8); //heapPageAddress

            //  Use the disk_store() function in the Device Manager module to write the heap page to the block found above
            // DISK_STORE arguements PID, Page Number, Block Number	
           
            R1 = DISK_STORE;
            R2 = [SYSTEM_STATUS_TABLE + 1];
            R3 = [heapPageAddress];
            R4 = swapBlockNumber;
            call DEVICE_MANAGER;
            
            multipop(R8); //heapPageAddress




            //  Call the release_page() function in the Memory Manager module to deallocate the page.
         
            R1 = RELEASE_PAGE;
            R2 = [heapPageAddress];
            call MEMORY_MANAGER;
            multipop(R1,R2,R3,R4,R5,R6,R7,R8);
            
            // Invalidate the Page table entry corresponding to the heap pages.
            [heapPageAddress] = -1;
            [heapPageAddress + 1] = "0000";

        endif;
        iter = iter + 2;
    endwhile;


    // Get two free swap block by calling the get_swap_block() function in the Memory Manager module.
    // Use the disk_store() function in the Device Manager module to write the two stack pages to the disk blocks found above.
    iter = 16;
    alias stackPageAddress R7;

    while(iter<20) do
        stackPageAddress = ptbr + iter;

        multipush(R1,R2,R3,R4,R5,R6);
        // No arguments
        // returns Block Number
        R1 = GET_SWAP_BLOCK;
        call MEMORY_MANAGER;
        multipop(R1,R2,R3,R4,R5,R6);
        
       alias swapBlockNumber R0;

        // DISK_STORE arguements PID, Page Number, Block Number	
        multipush(R1,R2,R3,R4,R5,R6);
        R1 = DISK_STORE;
        R2 = [SYSTEM_STATUS_TABLE + 1];
        R3 = [stackPageAddress];
        R4 = swapBlockNumber; // R0 return value from GET SWAP BLOCK
        call DEVICE_MANAGER;
        multipop(R1,R2,R3,R4,R5,R6);

        // Call the release_page() function in the Memory Manager module to deallocate the two pages.
        multipush(R1,R2,R3,R4,R5,R6);
        R1 = RELEASE_PAGE;
        R2 = [stackPageAddress];
        call MEMORY_MANAGER;
        multipop(R1,R2,R3,R4,R5,R6);

        // Update the Disk Map Table entry of the process to store the disk block numbers of the stack.
        [DISK_MAP_TABLE + swapOutProcessId * 10 + iter/2] = swapBlockNumber;



        // Invalidate the Page table entry corresponding to the two stack pages.
        [stackPageAddress] = -1;
        [stackPageAddress + 1] = "0000";

        iter = iter + 2;
    endwhile;

    // Set the SWAP_FLAG field in the process table entry of the process to 1.
    [processTableEntryAddress + 6] = 1;


    // In the System Status Table, increment the SWAP_COUNT and reset the PAGING_STATUS back to 0.   
    [SYSTEM_STATUS_TABLE + 4] = [SYSTEM_STATUS_TABLE + 4] + 1;
    // PAGING_STATUS to 0
    [SYSTEM_STATUS_TABLE + 5] = 0;

    // The scheduler can now resume normal scheduling
  

endif;

if(functionNumber == SWAP_IN) then
    // Find if any swapped out process can be made ready to run if brought into memory.
    // Loop through the Process Table and find the swapped process in the READY state with the highest TICK.
    alias swapInProcessId R3; // Process ID to swap In
    alias processTableEntryAddress R4;
    alias iter R5; // Loop iterator
    
    swapInProcessId = -1;
    iter = 2;

    while(iter < MAX_PROC_NUM)  do
        processTableEntryAddress = PROCESS_TABLE + iter * 16;
        if([processTableEntryAddress + 6] == 1 && [processTableEntryAddress + 4] == READY) then
            swapInProcessId = iter;
            break;
        endif;
        iter = iter + 1;
    endwhile;

    // If there is no such process in the READY state, reset the PAGING_STATUS field to 0 and Return.
    if(swapInProcessId == -1) then  
        [SYSTEM_STATUS_TABLE+5] = 0;
        return;
    endif;

    // Set the TICK field of the process table entry of the selected process to 0.
    [processTableEntryAddress] = 0;

    alias ptbr R6;
    ptbr = [processTableEntryAddress + 14];

    // Temporary registers in use
    alias diskMapHeapEntryAddress R7;
    diskMapHeapEntryAddress =  DISK_MAP_TABLE + swapInProcessId * 10   ;

    iter =2;
    
    // For each heap page that is swapped out ( Check the Disk Map Table. )
    while(iter<4) do
        alias heapBlockNumber R8;
        heapBlockNumber = [diskMapHeapEntryAddress+iter];
        if(heapBlockNumber!=-1) then


            // Call the get_free_page() function in the Memory Manager module to allocate a memory page.
            multipush(R1,R2,R3,R4,R5,R6,R7,R8);

            multipush(R8);//multipush(heapBlockNumber);

            R1 = GET_FREE_PAGE; // get free page function number
            call MEMORY_MANAGER;
      

            alias swapInMemoryPage R0;
            // Get the disk block number in the Disk Map Table entry of the process corresponding to the heap page.

            multipop(R8); //multipop(heapBlockNumber);
            multipush(R8); //multipush(heapBlockNumber);


            //  Use the disk_load() function in the Device Manager module to copy the heap page found above to the memory.
            R1 = DISK_LOAD ;// 2; // disk load function number
            R2 = [SYSTEM_STATUS_TABLE + 1];
            R3 = swapInMemoryPage ; //R0; // page number
            R4 = heapBlockNumber; // block number
            call DEVICE_MANAGER; // Device Manager Module
            
            multipop(R8);//multipop(heapBlockNumber);
            

            //  Free the swap block by calling the release_block() function in the Memory Manager module.
            R1 = RELEASE_BLOCK;
            R2 = heapBlockNumber;
            R3 = [SYSTEM_STATUS_TABLE+1];
            call MEMORY_MANAGER;
            multipop(R1,R2,R3,R4,R5,R6,R7,R8);

            // Set the Page table entry correpsonding to the page. Reference bit is set to 0, valid bit and write bit are set to 1.
            [ptbr+2*iter] = -1;
            [ptbr+2*iter+1] = "0110";

            // Invalidate the Disk Map Table entry corresponding to the heap page.
            [diskMapHeapEntryAddress+iter]=-1;


        endif;
        iter = iter +1;
    endwhile;

    

    iter = 8;
    alias stackBlockNumber R8;
    while(iter<10) do

        stackBlockNumber = [diskMapHeapEntryAddress+iter];
        if(stackBlockNumber!=-1) then
            // Get two free memory pages by calling the get_free_page() function in the Memory Manager module.
            multipush(R1,R2,R3,R4,R5,R6,R7,R8);
            R1 = GET_FREE_PAGE; // get free page function number
            call MEMORY_MANAGER;
            multipop(R1,R2,R3,R4,R5,R6,R7,R8);
        
            alias freeStackPage R0;
            // Use the disk_load() function in the Device Manager module to load the two stack pages to the memory allocated above.
            // DISK_LOAD arguements PID, Page Number, Block Number	
            multipush(R1,R2,R3,R4,R5,R6,R7,R8);
            R1 = DISK_LOAD;
            R2 = [SYSTEM_STATUS_TABLE + 1];
            R3 = freeStackPage;
            R4 = stackBlockNumber; 
            call DEVICE_MANAGER;
            multipop(R1,R2,R3,R4,R5,R6,R7,R8);

            // Set the Page table entries correpsonding to the two stack pages. The pages are valid, unreferenced and writable.
            [ptbr+2*iter] = -1;
            [ptbr+2*iter+1] = "0110";

            // Call the release_block() function in the Memory Manager module to deallocate the two swap blocks.
            multipush(R1,R2,R3,R4,R5,R6,R7,R8);
            R1 = RELEASE_BLOCK;
            R2 = stackBlockNumber;
            R3 = [SYSTEM_STATUS_TABLE+1];
            call MEMORY_MANAGER;
            multipop(R1,R2,R3,R4,R5,R6,R7,R8);

            // Invalidate the Disk Map Table entry of the process corresponding to the pages.
            [diskMapHeapEntryAddress+iter] = -1;

        endif;

        iter = iter + 2;
    endwhile;


    // Set the SWAP_FLAG field in the process table entry of the process to 0.
    [processTableEntryAddress + 6] = 0;

    // In the System Status Table, decrement the SWAP_COUNT and reset the PAGING_STATUS back to 0.   
    [SYSTEM_STATUS_TABLE + 4] = [SYSTEM_STATUS_TABLE + 4] - 1;
    [SYSTEM_STATUS_TABLE + 5] = 0;


    // The scheduler can now resume normal scheduling 


endif;

return;