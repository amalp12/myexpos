alias functionNum R1;
alias processId R2;

if(functionNum == GET_FREE_PAGE) then
    // Increment WAIT_MEM_COUNT field in the system status table. //Do not increment the WAIT_MEM_COUNT in busy loop (an important step )
    [SYSTEM_STATUS_TABLE+3] = [SYSTEM_STATUS_TABLE+3] + 1;
    while([SYSTEM_STATUS_TABLE+2] == 0)do
        // Set the state of the invoked process as WAIT_MEM.
        [PROCESS_TABLE+processId*16+4] = WAIT_MEM;
        multipush(R1,R2);    
        call SCHEDULER;
        multipop(R1,R2);
    endwhile;

    // Decrement the WAIT_MEM_COUNT field and MEM_FREE_COUNT field in the system status table. Note the sequence - increment WAIT_MEM_COUNT, waiting for the memory, decrement WAIT_MEM_COUNT.
    [SYSTEM_STATUS_TABLE+2] = [SYSTEM_STATUS_TABLE+2]  - 1;
    [SYSTEM_STATUS_TABLE+3] = [SYSTEM_STATUS_TABLE+3]  - 1;


    // Find a free page using memory free list and set the corresponding entry as 1. Make sure to store the obtained free page number in R0 as return value.
    alias freePage R3;
    alias count R4;
    freePage = MEMORY_FREE_LIST;
    count = 0;

    while(count < MAX_MEM_PAGE)do
        if([freePage] == 0)then
            [freePage] = 1;
            break;
        endif;
        freePage = freePage + 1;
        count = count + 1;
    endwhile; 

    if(count == MAX_MEM_PAGE)then
        freePage =-1;
    endif;
    R0=count;

    return;

endif;

if(functionNum ==  RELEASE_PAGE) then
    alias pageNumber R2;
    
    if([MEMORY_FREE_LIST+pageNumber] == 1) then
        // The Page number to be released is present in R2. Decrement the corresponding entry in the memory free list.
        [MEMORY_FREE_LIST+pageNumber] = 0;
        // If that entry in the memory free list becomes zero, then the page is free. So increment the MEM_FREE_COUNT in the system status table.
        [SYSTEM_STATUS_TABLE+2] = [SYSTEM_STATUS_TABLE+2] + 1;
    endif;

    // Update the STATUS to READY for all processes (with valid PID) which have STATUS as WAIT_MEM.
    alias processId R3;
    alias count R4;
    processId = 0;
    count = 0;
    while(count < 16)do
        if([PROCESS_TABLE+processId*16] != -1)then
            if([PROCESS_TABLE+processId*16+4] == WAIT_MEM)then
                [PROCESS_TABLE+processId*16+4] = READY;
            endif;
        endif;
        processId = processId + 1;
        count = count + 1;
    endwhile;
    
    return;
endif;

//GET CODE PAGE
if(functionNum ==  GET_CODE_PAGE) then // 5
    alias blockNumber R2;
    // Check the disk map table entries ofall the processes, if the given block number is present in any entry and the corresponding page table entry is valid then return the memory page number
    alias processId R3;
    processId = 0;
    while(processId < 16)do
        alias offset R4;
        offset = 0;
        // check if entry is already present 
        while(offset < 4) do
            if([DISK_MAP_TABLE + processId *10 + 4 + offset] == blockNumber) then
                // if entry is present then return the corresponding page number from the 
                alias ptbr R5;
                ptbr = [PROCESS_TABLE + processId * 16 + 14 ];
                if([ptbr + 8 + offset*2] != -1) then
                    R0 = [ptbr + 8 + offset*2];
                    [MEMORY_FREE_LIST + R0] = [MEMORY_FREE_LIST + R0] + 1;
                    return;
                endif;

            endif;
            offset = offset + 1;
        endwhile;
        processId = processId + 1;
    endwhile;


    // if not found then get free page from memroy and return that
    multipush(R1,R2);
    R1 = GET_FREE_PAGE;
    call MOD_2; // memory manager
    multipop(R1,R2);
    // calling DISK_LOAD
    multipush(R0,R1,R2);
    R1 = DISK_LOAD;
    R4 = blockNumber;
    R3 = R0;
    R2 = [SYSTEM_STATUS_TABLE + 1];
    call MOD_4; // disk manager
    multipop(R0,R1,R2);

    return ;
endif;

if(functionNum ==  RELEASE_BLOCK) then // 4
    alias blockNumber R2;
    alias processId R3;
    if([DISK_FREE_LIST + blockNumber]==1) then
        [DISK_FREE_LIST + blockNumber] = [DISK_FREE_LIST + blockNumber] - 1;
    endif;
    return;
endif;
